#!/usr/bin/env python3

# TODO: threaded dmenu prompt? Locking the browser sucks
# TODO: popup windows? they're sometimes legit
# TODO: tests pls
# TODO: site-specific searches, e.g. `pb` for piratebay
# TODO: window close undo? maintaining history and all.
# TODO: lastpass integration or roll my own because dammit last pass give me an
#       API, including basic auth

import code
import contextlib
import enum
import itertools
import os
import re
import shlex
import socket
import sqlite3
import subprocess
import sys
import threading

from urllib import parse as urlparse

from gi.repository import Gtk, Gdk, Notify, WebKit, GObject


Mode = enum.Enum('Mode', 'Insert Normal Motion SubCommand Command')


def run_javascript(script):
    def real_command(roland):
        roland.browser.execute_script(script)
    return real_command


class lazymeta(type):
    def __new__(cls, name, bases, attrs):
        mycls = type.__new__(cls, name, bases, attrs)
        return mycls()


class lazy(object, metaclass=lazymeta):
    def __getattr__(self, name):
        def lazy_command(*args, **kwargs):
            def real_command(browser):
                for_real_this_time = getattr(browser, name)
                return for_real_this_time(*args, **kwargs)
            return real_command
        return lazy_command


class Config:
    home_page = 'https://www.google.com'
    search_page = 'https://www.google.com/search?q=%s'

    commands = {
        'i': lazy.set_mode(Mode.Insert),
        'colon': lazy.set_mode(Mode.Command),

        'b': lambda browser: browser.roland.select_window(),
        'c': lazy.close(),
        'o': lazy.open_or_search(),
        'O': lazy.open_modify(),
        't': lazy.open_or_search(new_window=True),
        'T': lazy.open_modify(new_window=True),

        'r': lazy.reload(),
        'R': lazy.reload_bypass_cache(),

        'plus': lazy.zoom_in(),
        'minus': lazy.zoom_out(),
        'equal': lazy.zoom_reset(),

        'slash': lazy.search_page(forwards=True),
        'question': lazy.search_page(forwards=False),
        'n': lazy.next_search_result(forwards=True),
        'N': lazy.next_search_result(forwards=False),

        'C-o': lazy.back(),
        'C-i': lazy.forward(),

        'f': lazy.follow(),
        'F': lazy.follow(new_window=True),

        'C-f': run_javascript('window.scrollBy(0, window.innerHeight);'),
        'C-b': run_javascript('window.scrollBy(0, -window.innerHeight);'),

        'C-c': lazy.stop(),
        'C-w': lazy.shell(),
        'C-q': lazy.quit(),

        'h': lazy.move(x=-1),
        'j': lazy.move(y=1),
        'k': lazy.move(y=-1),
        'l': lazy.move(x=1),

        'y': lambda browser: browser.roland.set_clipboard(browser.get_uri()),
        'g': lazy.set_mode(Mode.SubCommand, 'g', {
            'g': run_javascript('window.scrollTo(0, 0);'),
        }),
        'd': lazy.set_mode(Mode.SubCommand, 'd', {
            'l': lazy.list_downloads(),
            'c': lazy.cancel_download(),
        }),

        'G': run_javascript('window.scrollBy(0, document.body.scrollHeight);'),
    }


class BrowserCommands(object):
    def open(self, url=None, new_window=False):
        url = url or self.roland.prompt("URL:", options=self.roland.most_popular_urls())
        if new_window:
            self.roland.new_window(url)
        else:
            self.browser.load_uri(url)

    def open_or_search(self, text=None, new_window=False):
        text = text or self.roland.prompt("URL:", options=self.roland.most_popular_urls(), default_first=False)
        if urlparse.urlparse(text).scheme:
            self.open(text, new_window=new_window)
        else:
            if ' ' in text or '_' in text:
                self.search(text, new_window=new_window)
            else:
                try:
                    socket.gethostbyname(text)
                except socket.error:
                    self.search(text)
                else:
                    self.open(make_uri(text), new_window=new_window)

    def close(self):
        self.window.close()
        self.window.destroy()

    def open_modify(self, new_window=False):
        url = self.roland.prompt("URL:", options=[self.browser.get_uri() or ''])
        self.open(url, new_window=new_window)

    def search(self, text=None, new_window=False):
        url = Config.search_page % urlparse.quote(text or self.roland.prompt('Search:'))
        self.open(url, new_window=new_window)

    def back(self):
        self.browser.go_back()

    def forward(self):
        self.browser.go_forward()

    def follow(self, new_window=False):
        dom = self.browser.get_dom_document()
        if new_window:
            elems = dom.query_selector_all('a')
        else:
            elems = dom.query_selector_all('a, input:not([type=hidden]), textarea, select, button')

        def is_visible(elem):
            return (elem.get_offset_height() != 0 or elem.get_offset_width() != 0)

        elems = [elems.item(i) for i in
                 xrange(elems.get_length()) if is_visible(elems.item(i))]

        overlay = dom.create_element('div')
        html = ''

        def get_offset(elem):
            x, y = 0, 0

            while elem is not None:
                x += elem.get_offset_left() - elem.get_scroll_left()
                y += elem.get_offset_top() - elem.get_scroll_top()
                elem = elem.get_offset_parent()
            return x, y

        for i, elem in enumerate(elems, 1):
            css = ''.join([
                'left: %dpx;',
                'top: %dpx;',
                'position: absolute;',
                'font-size: 13px;',
                'background-color: #ff6600;',
                'color: white;',
                'font-weight: bold;',
                'padding: 0px 1px;',
                'border: 2px solid black;',
                'z-index: 100000;'
            ]) % get_offset(elem)

            span = '<span style="%s">%d</span>' % (css, i)
            html += span

        overlay.set_inner_html(html)

        html_elem = dom.query_selector_all('html').item(0)
        html_elem.append_child(overlay)

        def threaded_prompt():
            try:
                choice = self.roland.prompt("Follow:")
            except AbortPromptError:
                return
            finally:
                html_elem.remove_child(overlay)

            elem = elems[int(choice)-1]

            if elem.get_tag_name().lower() == 'a':
                if new_window:
                    url = elem.get_href()
                    self.roland.new_window(url)
                else:
                    elem.click()
            else:
                elem.focus()
                self.set_mode(Mode.Insert)

        t = threading.Thread(target=threaded_prompt)
        t.start()

    def search_page(self, text=None, forwards=True, case_insensitive=None):
        self.previous_search = text = text or self.roland.prompt('Search:')

        # smart search
        if case_insensitive is None:
            case_insensitive = text.lower() != text

        self.browser.mark_text_matches(text, case_insensitive, 0)
        self.browser.set_highlight_text_matches(True)
        self.browser.search_text(text, case_insensitive, True, True)

    def next_search_result(self, forwards=True, case_insensitive=None):
        if self.previous_search:
            self.search_page(
                text=self.previous_search,
                forwards=forwards,
                case_insensitive=case_insensitive,
            )

    def zoom_in(self):
        self.browser.zoom_in()

    def zoom_out(self):
        self.browser.zoom_out()

    def zoom_reset(self):
        self.browser.set_zoom_level(1)

    def stop(self):
        self.browser.stop_loading()

    def move(self, x=0, y=0):
        self.browser.execute_script('window.scrollBy(%d, %d);' % (x*30, y*30))

    def shell(self):
        t = threading.Thread(target=code.interact, kwargs={'local': locals()})
        t.daemon = True
        t.start()

    def quit(self):
        if self.roland.is_enabled(DownloadManager) and self.roland.downloads:
            quit = self.roland.prompt_yes_no('Do you really want to quit? You have %d downloads running.' % len(self.roland.downloads))

            if not quit:
                return

            self.roland.quitting = True

            for download in self.roland.downloads.values():
                if download.get_progress() != 1.0:
                    download.cancel()
            return

        Gtk.main_quit()

    def reload(self):
        self.browser.reload()

    def reload_bypass_cache(self):
        self.browser.reload_bypass_cache()

    def cancel_download(self):
        if not self.roland.is_enabled(DownloadManager):
            self.roland.notify("Download manager not enabled")
            return

        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return

        name = self.roland.prompt("Cancel download:", options=self.roland.downloads.keys())

        try:
            download = self.roland.downloads[name]
        except KeyError:
            self.roland.notify("No download by that name")
        else:
            download.cancel()

    def list_downloads(self):
        if not self.roland.is_enabled(DownloadManager):
            self.roland.notify("Download manager not enabled")
            return

        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return

        for location, download in self.roland.downloads.items():
            if download.get_progress() == 1.0:
                continue  # completed while we were doing this
            progress = get_pretty_size(download.get_current_size())
            total = get_pretty_size(download.get_total_size())
            self.notify('%s - %s out of %s' % (location, progress, total))


class StatusLine(object):
    def __init__(self):
        self.left = Gtk.Label()
        self.middle = Gtk.Label()
        self.right = Gtk.Label()

        self.left.set_alignment(0.0, 0.5)
        self.right.set_alignment(1.0, 0.5)

    def set_mode(self, text):
        self.left.set_markup(text)

    def set_buffered_command(self, text):
        self.right.set_text(text)


class BrowserTitle(object):
    title = ''
    progress = 0

    def __str__(self):
        if self.progress < 100:
            return '[%d%%] Loading... %s' % (self.progress, self.title)
        return self.title or ''


class AbortPromptError(Exception):
    pass


class BrowserWindow(BrowserCommands):
    def __init__(self, roland):
        self.roland = roland
        self.previous_search = ''
        self.title = BrowserTitle()

    def start(self, url):
        self.window = Gtk.Window()
        self.window.set_default_size(1000, 800)
        self.window.connect('key-press-event', self.on_key_press_event)

        self.browser = WebKit.WebView()
        self.status_line = StatusLine()

        self.set_mode(Mode.Normal)

        self.browser.connect('notify::title', self.update_title_from_event)
        self.browser.connect('notify::progress', self.update_title_from_event)

        if self.roland.is_enabled(HistoryManager):
            self.browser.connect('navigation-policy-decision-requested', self.roland.on_navigation_policy_decision_requested)

        if self.roland.is_enabled(DownloadManager):
            self.browser.connect('download-requested', self.roland.on_download_requested)
            self.browser.connect('mime-type-policy-decision-requested', self.roland.on_mime_type_policy_decision_requested)

        box = Gtk.VBox()
        scrollable = Gtk.ScrolledWindow()
        scrollable.add(self.browser)
        box.pack_start(scrollable, True, True, 0)

        status_line = Gtk.HBox()
        status_line.add(self.status_line.left)
        status_line.add(self.status_line.middle)
        status_line.add(self.status_line.right)

        box.pack_end(status_line, False, False, 0)

        self.window.add(box)
        self.window.show_all()

        self.window.connect('delete-event', self.roland.remove_window, self)

        self.open(url)

    def update_title_from_event(self, widget, event):
        if event.name == 'title':
            title = self.browser.get_title()
            self.title.title = title
        elif event.name == 'progress':
            self.title.progress = int(self.browser.get_progress() * 100)

        title = str(self.title)

        self.window.set_title(title)

    def on_key_press_event(self, widget, event):
        def get_keyname():
            keyname = Gdk.keyval_name(event.keyval)
            fields = []
            if event.state & Gdk.ModifierType.CONTROL_MASK:
                fields.append('C')
            if event.state & Gdk.ModifierType.SUPER_MASK:
                fields.append('L')
            if event.state & Gdk.ModifierType.MOD1_MASK:
                fields.append('A')

            fields.append(keyname)
            return '-'.join(fields)

        keyname = get_keyname()

        if self.mode == Mode.Normal:
            try:
                command = Config.commands[keyname]
            except KeyError:
                pass
            else:
                with contextlib.suppress(AbortPromptError):
                    return command(self)
        elif self.mode == Mode.SubCommand:
            try:
                command = self.sub_commands[keyname]
            except KeyError:
                pass
            else:
                with contextlib.suppress(AbortPromptError):
                    return command(self)
            finally:
                self.set_mode(Mode.Normal)
                self.sub_commands = None
        else:
            assert self.mode == Mode.Insert

            if keyname == 'Escape':
                self.set_mode(Mode.Normal)

    def set_mode(self, mode, *args):
        assert mode in Mode
        self.mode = mode

        if mode == Mode.Normal:
            self.browser.set_can_focus(False)
            self.window.set_focus(None)
            self.status_line.set_mode('<b>NORMAL</b>')
            self.status_line.set_buffered_command('')
        elif mode == Mode.SubCommand:
            command, self.sub_commands = args

            self.browser.set_can_focus(False)
            self.window.set_focus(None)
            self.status_line.set_mode('<b>COMMAND</b>')
            self.status_line.set_buffered_command(command)
        elif mode == Mode.Command:
            try:
                command = list(shlex.split(self.roland.prompt('Command:', options=self.roland.get_commands(), default_first=False)))
                command, args = command[0], command[1:]

                # FIXME: handle missing commands
                command = getattr(self, command)

                # FIXME: handle bad invocation
                command(*args)

            finally:
                self.set_mode(Mode.Normal)
        else:
            assert mode == Mode.Insert, "Unknown Mode %s" % mode
            self.browser.set_can_focus(True)
            self.browser.grab_focus()
            self.status_line.set_mode('<b>INSERT</b>')
            self.status_line.set_buffered_command('')
            # stop event propagation to prevent dumping 'i' into webpage
            return True


class HistoryManager(object):
    config_path = os.path.expanduser('~/.config/roland/')

    def setup(self):
        self.create_history_db()
        parent = super(HistoryManager, self)
        if hasattr(parent, 'setup'):
            parent.setup()

    def create_history_db(self):
        try:
            os.makedirs(self.config_path)
        except OSError:
            pass

        conn = self.get_history_db()

        cursor = conn.cursor()
        cursor.execute('create table if not exists history '
                       '(url text, view_count integer)')
        conn.commit()
        conn.close()

    def get_history_db(self):
        return sqlite3.connect(os.path.join(self.config_path, 'history.db'))

    def on_navigation_policy_decision_requested(
            self, browser, frame, request, navigation_action, policy_decision):
        uri = request.get_uri()
        conn = self.get_history_db()
        cursor = conn.cursor()

        cursor.execute('select url from history where url = ?', (uri,))
        rec = cursor.fetchone()

        if rec is None:
            cursor.execute('insert into history (url, view_count)'
                           'values (?, 1)', (uri,))
        else:
            cursor.execute('update history set view_count = view_count + 1 '
                           'where url = ?', (uri,))
        conn.commit()
        conn.close()

        return False


class DownloadManager(object):
    save_location = os.path.expanduser('~/Downloads/')

    def __init__(self):
        super(DownloadManager, self).__init__()
        self.downloads = {}

    def on_download_requested(self, browser, download):
        save_path = os.path.join(self.save_location,
                                 download.get_suggested_filename())

        orig_save_path = save_path
        for i in itertools.count(1):
            if os.path.exists(save_path):
                save_path = orig_save_path + ('.%d' % i)
            else:
                break

        try:
            location = self.prompt(
                "Download location (%s):" % download.get_uri(), options=[save_path])
        except AbortPromptError:
            return False

        download.connect('notify::status', self.download_status_changed, location)
        download.set_destination_uri('file://' + location)
        self.downloads[location] = download
        return True

    def download_status_changed(self, download, status, location):
        if download.get_status() == WebKit.DownloadStatus.FINISHED:
            self.notify('Download finished: %s' % location)
        elif download.get_status() == WebKit.DownloadStatus.ERROR:
            self.notify('Download failed: %s' % location, critical=True)
        elif download.get_status() == WebKit.DownloadStatus.CANCELLED:
            self.downloads.pop(location)

            self.notify('Download cancelled: %s' % location)
            try:
                os.unlink(location)
            except OSError:
                pass

            if self.quitting and not self.downloads:
                Gtk.main_quit()

    def on_mime_type_policy_decision_requested(
            self, browser, frame, request, mime_type, policy_decision):
        if browser.can_show_mime_type(mime_type):
            return False
        policy_decision.download()
        return True


class Roland(HistoryManager, DownloadManager, GObject.GObject):
    __gsignals__ = {
        'new_browser': (GObject.SIGNAL_RUN_LAST, None, (str,)),
    }

    def __init__(self):
        super(Roland, self).__init__()
        self.windows = []
        self.quitting = False

    def do_new_browser(self, url):
        window = BrowserWindow(self)
        window.start(url)
        self.windows.append(window)

    def emit(self, *args):
        '''A thread safe emit.

        This is so follow(url, new_window=True) works as it requires a thread.
        '''
        GObject.idle_add(GObject.GObject.emit, self, *args)

    def setup(self):
        parent = super(Roland, self)
        if hasattr(parent, 'setup'):
            parent.setup()

    def is_enabled(self, cls):
        return isinstance(self, cls)

    def run(self):
        self.setup()

        try:
            import setproctitle
            setproctitle.setproctitle('roland')
        except Exception:
            pass

        self.new_window(Config.home_page if len(sys.argv) == 1 else make_uri(sys.argv[1]))

        Gtk.main()

    def new_window(self, url):
        self.emit('new-browser', url)

    def remove_window(self, window, event, browser_window):
        self.windows.remove(browser_window)
        if not self.windows:
            Gtk.main_quit()

    def notify(self, message, critical=False, header=''):
        if not Notify.is_initted():
            Notify.init('roland')
        n = Notify.Notification.new(header, message)
        if critical:
            n.set_urgency(Notify.Urgency.CRITICAL)
        n.show()

    def get_commands(self):
        return [f for f in dir(BrowserCommands) if not f.startswith('__')]

    def set_clipboard(self, text):
        primary = Gtk.Clipboard.get(Gdk.SELECTION_PRIMARY)
        secondary = Gtk.Clipboard.get(Gdk.SELECTION_SECONDARY)
        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

        primary.set_text(text, -1)
        secondary.set_text(text, -1)
        clipboard.set_text(text, -1)

    def prompt_yes_no(self, message):
        response = self.prompt(message, options=['yes', 'no'])
        return response.lower() == 'yes'

    def prompt(self, message, options=(), default_first=True):
        opts = ['dmenu', '-p', message]
        if default_first:
            opts.append('-df')
        opts = [s.encode('utf8') for s in opts]
        p = subprocess.Popen(opts, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE)
        stdout, stderr = p.communicate('\n'.join(options).encode('utf8'))

        if p.wait() != 0:
            raise AbortPromptError()
        return stdout.strip().decode('utf8')

    def most_popular_urls(self):
        if not self.is_enabled(HistoryManager):
            return []
        conn = self.get_history_db()
        cursor = conn.cursor()
        cursor.execute('select url from history order by view_count desc limit 50')
        urls = [url for (url,) in cursor.fetchall()]
        conn.close()
        return urls

    def select_window(self):
        windows = {'%d: %s' % (i, w.title.title): w for (i, w) in enumerate(self.windows)}
        win = self.prompt("Window", options=sorted(windows), default_first=False)
        win = windows[win]
        win.window.present()


def make_uri(s):
    if re.match(r'https?://', s):
        return s
    return 'http://' + s


def get_pretty_size(bytecount):
    size = bytecount

    for suffix in ['b', 'kb', 'mb', 'gb', 'tb', 'pb']:
        if size // 1024 < 1:
            return '%s%s' % (size, suffix)
        size //= 1024
    return '%s%s' % (size, suffix)


if __name__ == '__main__':
    Roland().run()
