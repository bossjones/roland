#!/usr/bin/env python2

# TODO: link follow support
# TODO: threaded dmenu prompt? Locking the browser sucks
# TODO: popup windows? they're sometimes legit
# TODO: tests pls
# TODO: lastpass integration or roll my own because dammit last pass give me an
#       API, including basic auth

import code
import enum
import itertools
import os
import re
import shlex
import socket
import sqlite3
import subprocess
import sys
import threading
import urllib2
import urlparse

from gi.repository import Gtk, Gdk, Notify, WebKit


Mode = enum.Enum('Mode', 'Insert Normal Motion SubCommand Command')


def run_javascript(script):
    def real_command(roland):
        roland.browser.execute_script(script)
    return real_command


def command(name, *args, **kwargs):
    def real_command(browser):
        for_real_this_time = getattr(browser, name)
        return for_real_this_time(*args, **kwargs)
    return real_command


normal_mode = {
    'i': command('set_mode', Mode.Insert),
    'colon': command('set_mode', Mode.Command),

    'c': command('close'),
    'o': command('open_or_search'),
    'O': command('open_modify'),
    'T': command('open_modify', new_window=True),

    'r': command('reload'),
    'R': command('reload_bypass_cache'),

    'plus': command('zoom_in'),
    'minus': command('zoom_out'),
    'equal': command('zoom_reset'),

    'slash': command('search_page', forwards=True),
    'question': command('search_page', forwards=False),
    'n': command('next_search_result', forwards=True),
    'N': command('next_search_result', forwards=False),

    'C-o': command('back'),
    'C-i': command('forward'),

    'f': command('follow'),
    'F': command('follow', new_window=True),

    'C-f': run_javascript('window.scrollBy(0, window.innerHeight);'),
    'C-b': run_javascript('window.scrollBy(0, -window.innerHeight);'),

    'C-c': command('stop'),
    'C-w': command('shell'),
    'C-q': command('quit'),

    'h': command('move', x=-1),
    'j': command('move', y=1),
    'k': command('move', y=-1),
    'l': command('move', x=1),

    'y': lambda roland: roland.set_clipboard(roland.browser.get_uri()),
    'g': command('set_mode', Mode.SubCommand, 'g', {
        'g': run_javascript('window.scrollTo(0, 0);'),
    }),
    'd': command('set_mode', Mode.SubCommand, 'd', {
        'l': command('list_downloads'),
        'c': command('cancel_download'),
    }),

    'G': run_javascript('window.scrollBy(0, document.body.scrollHeight);'),
}


class BrowserCommands(object):
    def open(self, url=None):
        self.browser.load_uri(url or self.roland.prompt("URL:", options=self.roland.most_popular_urls()))

    def open_or_search(self, text=None):
        text = text or self.roland.prompt("URL:", options=self.roland.most_popular_urls())
        if urlparse.urlparse(text).scheme:
            self.open(text)
        else:
            if ' ' in text or '_' in text:
                self.search(text)
            else:
                try:
                    socket.gethostbyname(text)
                except socket.error:
                    self.search(text)
                else:
                    self.browser.load_uri(make_uri(text))

    def close(self):
        self.window.destroy()
        self.roland.windows.remove(self)

    def open_modify(self, new_window=False):
        url = self.roland.prompt("URL:", options=[self.browser.get_uri() or ''])
        if new_window:
            self.roland.new_window(url)
        else:
            self.open(url)

    def search(self, text=None):
        self.open('http://www.google.com/search?q=%s' % urllib2.quote(text or self.roland.prompt('Search:')))

    def back(self):
        self.browser.go_back()

    def forward(self):
        self.browser.go_forward()

    def follow(self, new_window=False):
        raise NotImplementedError('follow')

    def search_page(self, text=None, forwards=True, case_insensitive=None):
        self.previous_search = text = text or self.roland.prompt('Search:')

        # smart search
        if case_insensitive is None:
            case_insensitive = text.lower() != text

        self.browser.mark_text_matches(text, case_insensitive, 0)
        self.browser.set_highlight_text_matches(True)
        self.browser.search_text(text, case_insensitive, True, True)

    def next_search_result(self, forwards=True, case_insensitive=None):
        if self.previous_search:
            self.search_page(
                text=self.previous_search,
                forwards=forwards,
                case_insensitive=case_insensitive,
            )

    def zoom_in(self):
        self.browser.zoom_in()

    def zoom_out(self):
        self.browser.zoom_out()

    def zoom_reset(self):
        self.browser.set_zoom_level(1)

    def stop(self):
        self.browser.stop_loading()

    def move(self, x=0, y=0):
        self.browser.execute_script('window.scrollBy(%d, %d);' % (x*30, y*30))

    def shell(self):
        t = threading.Thread(target=code.interact, kwargs={'local': locals()})
        t.daemon = True
        t.start()

    def quit(self):
        if self.roland.downloads:
            quit = self.roland.prompt_yes_no('Do you really want to quit? You have %d downloads running.' % len(self.roland.downloads))

            if not quit:
                return

            self.roland.quitting = True

            for download in self.roland.downloads.values():
                if download.get_progress() != 1.0:
                    download.cancel()
            return

        Gtk.main_quit()

    def reload(self):
        self.browser.reload()

    def reload_bypass_cache(self):
        self.browser.reload_bypass_cache()

    def cancel_download(self):
        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return

        name = self.roland.prompt("Cancel download:", options=self.roland.downloads.keys())

        try:
            download = self.roland.downloads[name]
        except KeyError:
            self.roland.notify("No download by that name")
        else:
            download.cancel()

    def list_downloads(self):
        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return
        for location, download in self.roland.downloads.items():
            if download.get_progress() == 1.0:
                continue  # completed while we were doing this
            progress = get_pretty_size(download.get_current_size())
            total = get_pretty_size(download.get_total_size())
            self.notify('%s - %s out of %s' % (location, progress, total))


class StatusLine(object):
    def __init__(self):
        self.left = Gtk.Label()
        self.middle = Gtk.Label()
        self.right = Gtk.Label()

        self.left.set_alignment(0.0, 0.5)
        self.right.set_alignment(1.0, 0.5)

    def set_mode(self, text):
        self.left.set_markup(text)

    def set_buffered_command(self, text):
        self.right.set_text(text)


class BrowserTitle(object):
    title = ''
    progress = 0

    def __str__(self):
        if self.progress < 100:
            return '[%d%%] Loading... %s' % (self.progress, self.title)
        return self.title or ''


class AbortPromptError(Exception):
    pass


def suppress(*exceptions):
    def decorator(func):
        def inner(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except exceptions:
                pass
        return inner
    return decorator


class BrowserWindow(BrowserCommands):
    def __init__(self, roland):
        self.roland = roland
        self.previous_search = ''
        self.title = BrowserTitle()

    def start(self, url):
        self.window = Gtk.Window()
        self.window.set_default_size(1000, 800)
        self.window.connect('key-press-event', self.on_key_press_event)
        self.window.connect('delete-event', lambda *args: self.quit())

        self.browser = WebKit.WebView()
        self.status_line = StatusLine()

        self.set_mode(Mode.Normal)

        self.browser.connect('notify::title', self.update_title_from_event)
        self.browser.connect('notify::progress', self.update_title_from_event)
        self.browser.connect('navigation-policy-decision-requested', self.roland.on_navigation_policy_decision_requested)
        self.browser.connect('download-requested', self.roland.on_download_requested)
        self.browser.connect('mime-type-policy-decision-requested', self.roland.on_mime_type_policy_decision_requested)

        box = Gtk.VBox()
        scrollable = Gtk.ScrolledWindow()
        scrollable.add(self.browser)
        box.pack_start(scrollable, True, True, 0)

        status_line = Gtk.HBox()
        status_line.add(self.status_line.left)
        status_line.add(self.status_line.middle)
        status_line.add(self.status_line.right)

        box.pack_end(status_line, False, False, 0)

        self.window.add(box)
        self.window.show_all()

        self.window.connect('delete-event', self.roland.remove_window, self)

        self.open(url)

    def update_title_from_event(self, widget, event):
        if event.name == 'title':
            title = self.browser.get_title()
            self.title.title = title
        elif event.name == 'progress':
            self.title.progress = int(self.browser.get_progress() * 100)

        title = str(self.title)

        self.window.set_title(title)

    @suppress(AbortPromptError)
    def on_key_press_event(self, widget, event):
        def get_keyname():
            keyname = Gdk.keyval_name(event.keyval)
            fields = []
            if event.state & Gdk.ModifierType.CONTROL_MASK:
                fields.append('C')
            if event.state & Gdk.ModifierType.SUPER_MASK:
                fields.append('L')
            if event.state & Gdk.ModifierType.MOD1_MASK:
                fields.append('A')

            fields.append(keyname)
            return '-'.join(fields)

        keyname = get_keyname()

        if self.mode == Mode.Normal:
            try:
                command = normal_mode[keyname]
            except KeyError:
                pass
            else:
                return command(self)
        elif self.mode == Mode.SubCommand:
            try:
                command = self.sub_commands[keyname]
                return command(self)
            except KeyError:
                pass
            finally:
                self.set_mode(Mode.Normal)
                self.sub_commands = None
        else:
            assert self.mode == Mode.Insert

            if keyname == 'Escape':
                self.set_mode(Mode.Normal)

    def set_mode(self, mode, *args):
        assert mode in Mode
        self.mode = mode

        if mode == Mode.Normal:
            self.browser.set_can_focus(False)
            self.window.set_focus(None)
            self.status_line.set_mode('<b>NORMAL</b>')
            self.status_line.set_buffered_command('')
        elif mode == Mode.SubCommand:
            command, self.sub_commands = args

            self.browser.set_can_focus(False)
            self.window.set_focus(None)
            self.status_line.set_mode('<b>COMMAND</b>')
            self.status_line.set_buffered_command(command)
        elif mode == Mode.Command:
            try:
                command = list(shlex.split(self.roland.prompt('Command:', options=self.roland.get_commands(), default_first=False)))
                command, args = command[0], command[1:]

                # FIXME: handle missing commands
                command = getattr(self, command)

                # FIXME: handle bad invocation
                command(*args)

            finally:
                self.set_mode(Mode.Normal)
        else:
            assert mode == Mode.Insert, "Unknown Mode %s" % mode
            self.browser.set_can_focus(True)
            self.browser.grab_focus()
            self.status_line.set_mode('<b>INSERT</b>')
            self.status_line.set_buffered_command('')
            # stop event propagation to prevent dumping 'i' into webpage
            return True


class Roland(object):
    def __init__(self):
        self.downloads = {}
        self.windows = []
        self.quitting = False

    def create_history_db(self):
        db_path = os.path.expanduser('~/.config/roland/')
        try:
            os.makedirs(db_path)
        except OSError:
            pass
        self.history_db = sqlite3.connect(db_path+'history.db')
        cursor = self.history_db.cursor()
        cursor.execute('create table if not exists history '
                       '(url text, view_count integer)')
        self.history_db.commit()

    def run(self):
        try:
            import setproctitle
            setproctitle.setproctitle('roland')
        except Exception:
            pass

        self.create_history_db()

        self.new_window('http://www.google.com' if len(sys.argv) == 1 else make_uri(sys.argv[1]))

        Gtk.main()

    def new_window(self, url):
        window = BrowserWindow(self)
        window.start(url)
        self.windows.append(window)

    def remove_window(self, window, event, browser_window):
        self.windows.remove(browser_window)

    def on_download_requested(self, browser, download):
        save_path = os.path.join(os.path.expanduser('~/Downloads/'),
                                 download.get_suggested_filename())

        orig_save_path = save_path
        for i in itertools.count(1):
            if os.path.exists(save_path):
                save_path = orig_save_path + ('.%d' % i)
            else:
                break

        try:
            location = self.prompt(
                "Download location (%s):" % download.get_uri(), options=[save_path])
        except AbortPromptError:
            return False

        download.connect('notify::status', self.download_status_changed, location)
        download.set_destination_uri('file://' + location)
        self.downloads[location] = download
        return True

    def download_status_changed(self, download, status, location):
        if download.get_status() == WebKit.DownloadStatus.FINISHED:
            self.notify('Download finished: %s' % location)
        elif download.get_status() == WebKit.DownloadStatus.ERROR:
            self.notify('Download failed: %s' % location, critical=True)
        elif download.get_status() == WebKit.DownloadStatus.CANCELLED:
            self.downloads.pop(location)

            self.notify('Download cancelled: %s' % location)
            try:
                os.unlink(location)
            except OSError:
                pass

            if self.quitting and not self.downloads:
                Gtk.main_quit()

    def notify(self, message, critical=False, header=''):
        if not Notify.is_initted():
            Notify.init('roland')
        n = Notify.Notification.new(header, message)
        if critical:
            n.set_urgency(Notify.Urgency.CRITICAL)
        n.show()

    def on_mime_type_policy_decision_requested(
            self, browser, frame, request, mime_type, policy_decision):
        if browser.can_show_mime_type(mime_type):
            return False
        policy_decision.download()
        return True

    def on_navigation_policy_decision_requested(
            self, browser, frame, request, navigation_action, policy_decision):
        uri = request.get_uri()
        cursor = self.history_db.cursor()

        cursor.execute('select url from history where url = ?', (uri,))
        rec = cursor.fetchone()

        if rec is None:
            cursor.execute('insert into history (url, view_count)'
                           'values (?, 1)', (uri,))
        else:
            cursor.execute('update history set view_count = view_count + 1 '
                           'where url = ?', (uri,))
        self.history_db.commit()

        return False

    def get_commands(self):
        return [f for f in dir(BrowserCommands) if not f.startswith('__')]

    def set_clipboard(self, text):
        primary = Gtk.Clipboard.get(Gdk.SELECTION_PRIMARY)
        secondary = Gtk.Clipboard.get(Gdk.SELECTION_SECONDARY)
        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

        primary.set_text(text, -1)
        secondary.set_text(text, -1)
        clipboard.set_text(text, -1)

    def prompt_yes_no(self, message):
        response = self.prompt(message, options=['yes', 'no'])
        return response.lower() == 'yes'

    def prompt(self, message, options=(), default_first=True):
        opts = ['dmenu', '-p', message]
        if default_first:
            opts.append('-df')
        p = subprocess.Popen(opts, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE)
        stdout, stderr = p.communicate('\n'.join(options))

        if p.wait() != 0:
            raise AbortPromptError()
        return stdout.strip()

    def most_popular_urls(self):
        cursor = self.history_db.cursor()
        cursor.execute('select url from history order by view_count desc limit 50')
        return [url for (url,) in cursor.fetchall()]


def make_uri(s):
    if re.match(r'https?://', s):
        return s
    return 'http://' + s


def get_pretty_size(bytecount):
    size = bytecount

    for suffix in ['b', 'kb', 'mb', 'gb', 'tb', 'pb']:
        if size // 1024 < 1:
            return '%s%s' % (size, suffix)
        size //= 1024
    return '%s%s' % (size, suffix)


if __name__ == '__main__':
    Roland().run()
