#!/usr/bin/env python3

import builtins
import code
import contextlib
import enum
import imp
import itertools
import os
import re
import shlex
import socket
import sqlite3
import subprocess
import sys
import threading
import traceback

from urllib import parse as urlparse

from gi.repository import Gio, Gtk, Gdk, Notify, WebKit, GObject, Soup


Mode = enum.Enum('Mode', 'Insert Normal Motion SubCommand Command')


class RolandModule:
    Mode = Mode

    class lazymeta(type):
        def __new__(cls, name, bases, attrs):
            mycls = type.__new__(cls, name, bases, attrs)
            return mycls()

    class lazy(object, metaclass=lazymeta):
        def __getattr__(self, name):
            def lazy_command(*args, **kwargs):
                def real_command(browser):
                    for_real_this_time = getattr(browser, name)
                    return for_real_this_time(*args, **kwargs)
                return real_command
            return lazy_command


class BrowserCommands:
    def open(self, url=None, new_window=False):
        url = url or self.roland.prompt("URL:", options=self.roland.most_popular_urls())
        if new_window:
            self.roland.new_window(url)
        else:
            self.webview.load_uri(url)

    def open_or_search(self, text=None, new_window=False):
        text = text or self.roland.prompt("URL:", options=self.roland.most_popular_urls(), default_first=False)
        if urlparse.urlparse(text).scheme:
            self.open(text, new_window=new_window)
        else:
            if ' ' in text or '_' in text:
                self.search(text, new_window=new_window)
            else:
                try:
                    socket.gethostbyname(text)
                except socket.error:
                    self.search(text)
                else:
                    self.open('http://'+text, new_window=new_window)

    def close(self):
        # explicitly trigger quitting in case downloads are in progress
        if len(self.roland.get_windows()) == 1:
            self.roland.quit()
            return

        Gtk.Window.close(self)
        Gtk.Window.destroy(self)

    def open_modify(self, new_window=False):
        url = self.roland.prompt("URL:", options=[self.webview.get_uri() or ''])
        self.open(url, new_window=new_window)

    def search(self, text=None, new_window=False):
        url = self.roland.config.search_page % urlparse.quote(text or self.roland.prompt('Search:'))
        self.open(url, new_window=new_window)

    def back(self):
        self.webview.go_back()

    def forward(self):
        self.webview.go_forward()

    def run_javascript(self, script):
        self.webview.execute_script(script)

    def follow(self, new_window=False):
        dom = self.webview.get_dom_document()
        if new_window:
            elems = dom.query_selector_all('a')
        else:
            elems = dom.query_selector_all('a, input:not([type=hidden]), textarea, select, button')

        def is_visible(elem):
            return (elem.get_offset_height() != 0 or elem.get_offset_width() != 0)

        elems = [elems.item(i) for i in
                 range(elems.get_length()) if is_visible(elems.item(i))]

        overlay = dom.create_element('div')
        html = ''

        def get_offset(elem):
            x, y = 0, 0

            while elem is not None:
                x += elem.get_offset_left() - elem.get_scroll_left()
                y += elem.get_offset_top() - elem.get_scroll_top()
                elem = elem.get_offset_parent()
            return x, y

        for i, elem in enumerate(elems, 1):
            css = ''.join([
                'left: %dpx;',
                'top: %dpx;',
                'position: absolute;',
                'font-size: 13px;',
                'background-color: #ff6600;',
                'color: white;',
                'font-weight: bold;',
                'padding: 0px 1px;',
                'border: 2px solid black;',
                'z-index: 100000;'
            ]) % get_offset(elem)

            span = '<span style="%s">%d</span>' % (css, i)
            html += span

        overlay.set_inner_html(html)

        html_elem = dom.query_selector_all('html').item(0)
        html_elem.append_child(overlay)

        def threaded_prompt():
            try:
                choice = self.roland.prompt("Follow:")
            except AbortPromptError:
                return
            finally:
                html_elem.remove_child(overlay)

            elem = elems[int(choice)-1]

            if elem.get_tag_name().lower() == 'a':
                if new_window:
                    url = elem.get_href()
                    self.roland.new_window(url)
                else:
                    elem.click()
            else:
                elem.focus()
                self.set_mode(Mode.Insert)

        t = threading.Thread(target=threaded_prompt)
        t.start()

    def search_page(self, text=None, forwards=True, case_insensitive=None):
        self.previous_search = text = text or self.roland.prompt('Search:')

        # smart search
        if case_insensitive is None:
            case_insensitive = text.lower() != text

        self.webview.mark_text_matches(text, case_insensitive, 0)
        self.webview.set_highlight_text_matches(True)
        self.webview.search_text(text, case_insensitive, True, True)

    def next_search_result(self, forwards=True, case_insensitive=None):
        if self.previous_search:
            self.search_page(
                text=self.previous_search,
                forwards=forwards,
                case_insensitive=case_insensitive,
            )

    def zoom_in(self):
        self.webview.zoom_in()

    def zoom_out(self):
        self.webview.zoom_out()

    def zoom_reset(self):
        self.webview.set_zoom_level(1)

    def stop(self):
        self.webview.stop_loading()

    def move(self, x=0, y=0):
        self.webview.execute_script('window.scrollBy(%d, %d);' % (x*30, y*30))

    def shell(self):
        t = threading.Thread(target=code.interact, kwargs={'local': locals()})
        t.daemon = True
        t.start()

    def quit(self):
        self.roland.quit()

    def reload(self):
        self.webview.reload()

    def reload_bypass_cache(self):
        self.webview.reload_bypass_cache()

    def cancel_download(self):
        if not self.roland.is_enabled(DownloadManager):
            self.roland.notify("Download manager not enabled")
            return

        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return

        name = self.roland.prompt("Cancel download:", options=self.roland.downloads.keys())

        try:
            download = self.roland.downloads[name]
        except KeyError:
            self.roland.notify("No download by that name")
        else:
            download.cancel()

    def list_downloads(self):
        if not self.roland.is_enabled(DownloadManager):
            self.roland.notify("Download manager not enabled")
            return

        if not self.roland.downloads:
            self.roland.notify("No downloads in progress")
            return

        for location, download in self.roland.downloads.items():
            if download.get_progress() == 1.0:
                continue  # completed while we were doing this
            progress = get_pretty_size(download.get_current_size())
            total = get_pretty_size(download.get_total_size())
            self.roland.notify('%s - %s out of %s' % (location, progress, total))


class StatusLine:
    def __init__(self):
        self.left = Gtk.Label()
        self.middle = Gtk.Label()
        self.right = Gtk.Label()

        self.left.set_alignment(0.0, 0.5)
        self.right.set_alignment(1.0, 0.5)

    def set_mode(self, text):
        self.left.set_markup(text)

    def set_buffered_command(self, text):
        self.right.set_text(text)


class BrowserTitle:
    title = ''
    progress = 0

    def __str__(self):
        if self.progress < 100:
            return '[%d%%] Loading... %s' % (self.progress, self.title)
        return self.title or ''


class AbortPromptError(Exception):
    pass


class BrowserWindow(BrowserCommands, Gtk.Window):
    def __init__(self, roland):
        super().__init__()
        self.roland = roland
        self.previous_search = ''
        self.title = BrowserTitle()
        self.webview = None
        self.sub_commands = None

    @classmethod
    def from_webview(cls, browser, roland):
        self = cls(roland)
        self.webview = browser
        self.webview.connect('web-view-ready', lambda *args: self.start(None))
        return self

    def start(self, url):
        self.set_default_size(1000, 800)
        self.connect('key-press-event', self.on_key_press_event)

        # will already be initialised for popups
        if self.webview is None:
            self.webview = WebKit.WebView()
        self.status_line = StatusLine()

        self.set_mode(Mode.Normal)

        self.webview.connect('notify::title', self.update_title_from_event)
        self.webview.connect('notify::progress', self.update_title_from_event)
        self.webview.connect('close-web-view', lambda *args: self.destroy())
        self.webview.connect('create-web-view', self.on_create_web_view)

        if self.roland.is_enabled(HistoryManager):
            self.webview.connect('navigation-policy-decision-requested', self.roland.on_navigation_policy_decision_requested)

        if self.roland.is_enabled(DownloadManager):
            self.webview.connect('download-requested', self.roland.on_download_requested)
            self.webview.connect('mime-type-policy-decision-requested', self.roland.on_mime_type_policy_decision_requested)

        box = Gtk.VBox()
        scrollable = Gtk.ScrolledWindow()
        scrollable.add(self.webview)
        box.pack_start(scrollable, True, True, 0)

        status_line = Gtk.HBox()
        status_line.add(self.status_line.left)
        status_line.add(self.status_line.middle)
        status_line.add(self.status_line.right)

        box.pack_end(status_line, False, False, 0)

        self.add(box)
        self.show_all()

        # will be None for popups
        if url is not None:
            self.open_or_search(url)

    def update_title_from_event(self, widget, event):
        if event.name == 'title':
            title = self.webview.get_title()
            self.title.title = title
        elif event.name == 'progress':
            self.title.progress = int(self.webview.get_progress() * 100)

        title = str(self.title)

        self.set_title(title)

    def on_create_web_view(self, webview, webframe):
        if self.roland.hooks('should_open_popup', webframe.get_uri(), default=True):
            v = WebKit.WebView()
            self.roland.windows.append(BrowserWindow.from_webview(v, self.roland))
            return v

    def on_key_press_event(self, widget, event):
        def get_keyname():
            keyname = Gdk.keyval_name(event.keyval)
            fields = []
            if event.state & Gdk.ModifierType.CONTROL_MASK:
                fields.append('C')
            if event.state & Gdk.ModifierType.SUPER_MASK:
                fields.append('L')
            if event.state & Gdk.ModifierType.MOD1_MASK:
                fields.append('A')

            fields.append(keyname)
            return '-'.join(fields)

        keyname = get_keyname()

        if self.mode in (Mode.Normal, Mode.SubCommand):
            available_commands = {
                Mode.Normal: self.roland.config.commands,
                Mode.SubCommand: self.sub_commands,
            }[self.mode]

            orig_mode = self.mode

            try:
                command = available_commands[keyname]
            except KeyError:
                pass
            else:
                try:
                    with contextlib.suppress(AbortPromptError):
                        return command(self)
                except Exception as e:
                    self.roland.notify("Error invoking command '{}': {}'".format(keyname, e))
            finally:
                if orig_mode == Mode.SubCommand:
                    self.set_mode(Mode.Normal)
                    self.sub_commands = None
        else:
            assert self.mode == Mode.Insert

            if keyname == 'Escape':
                self.set_mode(Mode.Normal)

    def set_mode(self, mode, *args):
        assert mode in Mode
        self.mode = mode

        if mode == Mode.Normal:
            self.webview.set_can_focus(False)
            self.set_focus(None)
            self.status_line.set_mode('<b>NORMAL</b>')
            self.status_line.set_buffered_command('')
        elif mode == Mode.SubCommand:
            command, self.sub_commands = args

            self.webview.set_can_focus(False)
            self.set_focus(None)
            self.status_line.set_mode('<b>COMMAND</b>')
            self.status_line.set_buffered_command(command)
        elif mode == Mode.Command:
            try:
                command = list(shlex.split(self.roland.prompt('Command:', options=self.roland.get_commands(), default_first=False)))
                command_name, args = command[0], command[1:]
                self.run_command(command_name, *args)
            finally:
                self.set_mode(Mode.Normal)
        else:
            assert mode == Mode.Insert, "Unknown Mode %s" % mode
            self.webview.set_can_focus(True)
            self.webview.grab_focus()
            self.status_line.set_mode('<b>INSERT</b>')
            self.status_line.set_buffered_command('')
            # stop event propagation to prevent dumping 'i' into webpage
            return True

    def run_command(self, name, *args):
        try:
            command = getattr(self, name)
        except AttributeError:
            self.roland.notify("No such command '{}'".format(name))
            return

        try:
            command(*args)
        except AbortPromptError:
            pass
        except Exception as e:
            self.roland.notify("Error calling '{}': {}".format(name, str(e)))
            traceback.print_exc()


class HistoryManager:
    def setup(self):
        self.create_history_db()
        getattr(super(), 'setup', lambda: None)()

    def create_history_db(self):
        conn = self.get_history_db()

        cursor = conn.cursor()
        cursor.execute('create table if not exists history '
                       '(url text, view_count integer)')
        conn.commit()
        conn.close()

    def get_history_db(self):
        return sqlite3.connect(config_path('history.db'))

    def on_navigation_policy_decision_requested(
            self, browser, frame, request, navigation_action, policy_decision):
        uri = request.get_uri()
        conn = self.get_history_db()
        cursor = conn.cursor()

        cursor.execute('select url from history where url = ?', (uri,))
        rec = cursor.fetchone()

        if rec is None:
            cursor.execute('insert into history (url, view_count)'
                           'values (?, 1)', (uri,))
        else:
            cursor.execute('update history set view_count = view_count + 1 '
                           'where url = ?', (uri,))
        conn.commit()
        conn.close()

        return False


class DownloadManager:
    save_location = os.path.expanduser('~/Downloads/')

    def setup(self):
        self.downloads = {}
        getattr(super(), 'setup', lambda: None)()

    def on_download_requested(self, browser, download):
        save_path = os.path.join(self.save_location,
                                 download.get_suggested_filename())

        orig_save_path = save_path
        for i in itertools.count(1):
            if os.path.exists(save_path):
                save_path = orig_save_path + ('.%d' % i)
            else:
                break

        try:
            location = self.prompt(
                "Download location (%s):" % download.get_uri(), options=[save_path])
        except AbortPromptError:
            return False

        download.connect('notify::status', self.download_status_changed, location)
        download.set_destination_uri('file://' + location)
        self.downloads[location] = download
        return True

    def download_status_changed(self, download, status, location):
        if download.get_status() == WebKit.DownloadStatus.FINISHED:
            self.notify('Download finished: %s' % location)
            self.downloads.pop(location)
        elif download.get_status() == WebKit.DownloadStatus.ERROR:
            self.notify('Download failed: %s' % location, critical=True)
            self.downloads.pop(location)
        elif download.get_status() == WebKit.DownloadStatus.CANCELLED:
            self.downloads.pop(location)

            self.notify('Download cancelled: %s' % location)
            try:
                os.unlink(location)
            except OSError:
                pass

    def on_mime_type_policy_decision_requested(
            self, browser, frame, request, mime_type, policy_decision):
        if browser.can_show_mime_type(mime_type):
            return False
        policy_decision.download()
        return True


class CookieManager:
    def setup(self):
        self.cookiejar = Soup.CookieJarDB.new(config_path('cookies.db'), False)
        self.cookiejar.set_accept_policy(Soup.CookieJarAcceptPolicy.ALWAYS)
        self.session = WebKit.get_default_session()
        self.session.add_feature(self.cookiejar)
        getattr(super(), 'setup', lambda: None)()


class Roland(HistoryManager, DownloadManager, CookieManager, Gtk.Application):
    __gsignals__ = {
        'new_browser': (GObject.SIGNAL_RUN_LAST, None, (str,)),
    }

    def __init__(self):
        Gtk.Application.__init__(self, application_id='deschain.roland', flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE)
        self.setup_run = False
        self.connect('command-line', self.on_command_line)

    def do_new_browser(self, url):
        window = BrowserWindow(self)
        window.start(url)
        self.add_window(window)

    def emit(self, *args):
        '''A thread safe emit.

        This is so follow(url, new_window=True) works as it requires a thread.
        '''
        GObject.idle_add(GObject.GObject.emit, self, *args)

    def load_config(self):
        sys.modules['roland'] = RolandModule()
        self.config = imp.load_source('roland', config_path('config.py'))

    def setup(self):
        if self.setup_run:
            return

        self.setup_run = True

        try:
            import setproctitle
            setproctitle.setproctitle('roland')
        except Exception:
            pass

        try:
            os.makedirs(config_path(''))
        except OSError:
            pass

        self.load_config()
        getattr(super(), 'setup', lambda: None)()

    def is_enabled(self, cls):
        return isinstance(self, cls)

    def on_command_line(self, roland, command_line):
        self.setup()
        urls = command_line.get_arguments()[1:] or [self.config.home_page]

        for url in urls:
            self.do_new_browser(url)

        return 0

    def new_window(self, url):
        self.emit('new-browser', url)

    def notify(self, message, critical=False, header=''):
        if not Notify.is_initted():
            Notify.init('roland')
        n = Notify.Notification.new(header, message)
        if critical:
            n.set_urgency(Notify.Urgency.CRITICAL)
        n.show()

    def get_commands(self):
        return [f for f in dir(BrowserCommands) if not f.startswith('__')]

    def set_clipboard(self, text, notify=True):
        primary = Gtk.Clipboard.get(Gdk.SELECTION_PRIMARY)
        secondary = Gtk.Clipboard.get(Gdk.SELECTION_SECONDARY)
        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

        primary.set_text(text, -1)
        secondary.set_text(text, -1)
        clipboard.set_text(text, -1)

        if notify:
            self.notify("Set clipboard to '{}'".format(text))

    def prompt_yes_no(self, message):
        response = self.prompt(message, options=['yes', 'no'])
        return response.lower() == 'yes'

    def prompt(self, message, options=(), default_first=True):
        opts = ['dmenu', '-p', message]
        if default_first:
            opts.append('-df')
        opts = [s.encode('utf8') for s in opts]
        p = subprocess.Popen(opts, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE)
        stdout, stderr = p.communicate('\n'.join(options).encode('utf8'))

        if p.wait() != 0:
            raise AbortPromptError()
        return stdout.strip().decode('utf8')

    def most_popular_urls(self):
        if not self.is_enabled(HistoryManager):
            return []
        conn = self.get_history_db()
        cursor = conn.cursor()
        cursor.execute('select url from history order by view_count desc limit 50')
        urls = [url for (url,) in cursor.fetchall()]
        conn.close()
        return urls

    def select_window(self):
        windows = {'%d: %s' % (i, w.title.title): w for (i, w) in enumerate(self.windows)}
        win = self.prompt("Window", options=sorted(windows), default_first=False)
        win = windows[win]
        win.window.present()

    def hooks(self, name, *args, default=None):
        return getattr(self.config, name, lambda *args: default)(*args)

    def quit(self):
        if self.is_enabled(DownloadManager) and self.downloads:
            quit = self.prompt_yes_no('Do you really want to quit? You have %d downloads running.' % len(self.downloads))

            if not quit:
                return

            while self.downloads:
                downloads = list(self.downloads.values())
                if not downloads:
                    break
                download = downloads[0]
                if download.get_progress() != 1.0:
                    download.cancel()

        Gtk.Application.quit(self)


def get_pretty_size(bytecount):
    size = bytecount

    for suffix in ['b', 'kb', 'mb', 'gb', 'tb', 'pb']:
        if size // 1024 < 1:
            return '%d%s' % (size, suffix)
        size /= 1024
    return '%d%s' % (size, suffix)


def config_path(t):
    return os.path.expanduser('~/.config/roland/{}'.format(t))


if __name__ == '__main__':
    Roland().run(sys.argv)
